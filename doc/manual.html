<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
lang="en">
<head>
<title>Lunary</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<link rel="stylesheet" href="doc.css" type="text/css"/>
</head>
<body>

<div class="chapter" id="header">
<img width="128" height="128" alt="Lunary" src="lunary.png"/>
<p>A binary format I/O framework for Lua</p>
<p class="bar">
<a href="index.html">home</a> &middot;
<a href="index.html#download">download</a> &middot;
<a href="index.html#installation">installation</a> &middot;
<a href="manual.html">manual</a> &middot;
<a href="examples.html">examples</a>
</p>
</div>

<div class="chapter">
<h1>4 - <a name="manual">Manual</a></h1>


<h2>4.1 - General library description</h2>

<p>The Lunary framework is organized as a collection of data type descriptions. Basic data types include for example 8-bit integers, C strings, enums. Each data type has a unique name, and can have parameters. Datatypes can be described by different means. Ultimately, each data type will be manipulated with three functions, named according to the data type, and located in the following tables: <code>serial.read</code>, <code>serial.serialize</code> and <code>serial.write</code>.</p>

<p><code>serial.read</code> contains functions that can be used to read a data object, of a given data type, from a data stream. For example the function <code>serial.read.uint8</code> can be used to read an unsigned 8 bit integer number. The general function prototype is:</p>

<pre><code>function serial.read.&lt;type name&gt;(&lt;stream&gt;, [type parameters])
</code></pre>

<p>For a description of the stream object, see the <em>Streams</em> section below. The type parameters are dependent on the data type, and may be used to reduce the overall number of data types and group similar types. A data type can have any number of type parameters. For example, Lunary provides a single <code>uint32</code> datatype, but support both big-endian and little-endian integers. The endianness is specified as the first type parameter.</p>

<p><code>serial.serialize</code> functions that can be used to serialize a data object into a byte string. The general function prototype is:</p>

<pre><code>function serial.serialize.&lt;type name&gt;(&lt;value&gt;, [type parameters])
</code></pre>

<p>Finally <code>serial.write</code> contains functions that can be used to write a data object to a data stream. The general function prototype is:</p>

<pre><code>function serial.write.&lt;type name&gt;(&lt;stream&gt;, &lt;value&gt;, [type parameters])
</code></pre>

<p>The <code>serial.serialize</code> and <code>serial.write</code> tables are a little redundant. It is possible to create a <code>write</code> function from a <code>serialize</code> function, and vice versa. Actually, when implementing data types, it is not necessary to provide both of these functions. The other one will be automatically generated by Lunary if missing. However, when using complex data types, depending on the situation one function may be faster than the other. So when performance becomes important, it is a good idea to provide both a <code>write</code> and a <code>serialize</code> function for your new data types.</p>

<h2>4.2 - Streams</h2>

<p>The Lunary framework was originally created to write a proxy for a binary network protocol. This is why Lunary serialization functions expect a stream object implementing the LuaSocket socket interface. However Lunary provides a way to wrap standard Lua file objects and have them behave as LuaSocket streams.</p>

<p>Stream objects as used by Lunary should be Lua object (implemented with any indexable Lua type), which provide methods. The methods to implement depend on the serialization functions used, and on the data type that is serialized. For basic data types, the <code>serial.write</code> functions expect a <code>send</code> method, and the <code>serial.read</code> functions expect a <code>receive</code> methods, defined as:</p>

<pre><code>function stream:send(data)
function stream:receive(pattern, [prefix])
</code></pre>

<p>where <code>data</code> is a Lua string containing the bytes to write to the stream, <code>pattern</code> is format specifier as defined in the <a href="http://www.lua.org/manual/5.1/manual.html#pdf-file:read">file:read</a> standard Lua API, and <code>prefix</code> is a string which will be prefixed to the <code>receive</code> return value.</p>

<p>One other methods used by some data types described below is <code>length</code>:</p>

<pre><code>function stream:length()
function stream:skip(nbytes)
</code></pre>

<p>The <code>length</code> method returns the number of bytes available in the stream. For network sockets, this makes no sense, but that information is available for file and buffer streams. That method is used by some data types which serialized length cannot be infered from the type description or content. For example array running to the end of the file or file section need that method when reading a stream.</p>

<p>As you can guess from the stream API we just described, the Lunary library is not capable of reading or writing data types that are not a multiple of a byte. As a consequence, since there is no way to read anything below 8 bits at once, bit order within a byte is never specified as a type parameter, as opposed to byte order within multibyte types.</p>

<h2>4.3 - Compound data types</h2>

<p>Lunary provides several basic data types, and some more complex compound data types. These types are generally more complicated to use, this section provides details about them.</p>

<h3>4.3.1 - Type description as type parameters</h3>

<p>Most of these compound data types contain sub-elements, but are described in the Lunary source code in a generic way. To use them with a given type for their sub-elements, a type description has to be given as one or more of their type parameters. Usually, type description as type parameters are passed as a Lua array, with the first array entry being the sub-element type name, and subsequent array entries being the sub-type type parameters. However when only a single sub-type description is necessary, the array may be expected as unpacked at the end of the parent type-parameter list. For example, to read an array or ten 8-bit numbers, one can call:</p>

<pre><code>serial.read.array(stream, 10, 'uint8')
</code></pre>

<p>When several sub-types are necessary, they are passed in Lua tables. So for example to read an array of C strings, prefixed by the number of string in a little-endian 16-bit integer, one can call:</p>

<pre><code>serial.read.sizedarray(stream, {'uint16', 'le'}, {'cstring'})
</code></pre>

<h3>4.3.2 - Naming <code>struct</code>-based and <code>fstruct</code>-based data types, aliases</h3>

<p>The <code>struct</code> and <code>fstruct</code> (as described below) are very handy to describe complex compound types. However, when such types are reused in several part of more complex data types, or in several root data types (like in several file formats), it may be handy to refer to them with names. The basic way to do it is to store the type parameters in Lua variables. For example one can write:</p>

<pre><code>local attribute = {
    {'name', 'cstring'},
    {'value', 'uint32', 'le'},
}
serial.read.struct(stream, attribute)
</code></pre>

<p>To share data types between libraries though, this may not be very handy. Lunary provides a way to define named data types. To do that three tables in the <code>serial</code> module are available: <code>serial.struct</code>, <code>serial.fstruct</code> and <code>serial.alias</code>. The first two are used to create named types based on structs and fstructs respectively, while the last one is used to give a name to any type. For example, the above <code>attribute</code> data type can be created like that:</p>

<pre><code>serial.struct.attribute = {
    {'name', 'cstring'},
    {'value', 'uint32', 'le'},
}
</code></pre>

<p>This will automatically generate <code>read</code>, <code>serialize</code> and <code>write</code> functions for that type, which can be used as follow:</p>

<pre><code>serial.read.attribute(stream)
</code></pre>

<p>The <code>fstruct</code> works similarly for fstructs (see below). The <code>alias</code> table, will contain type description arrays as expected by the <code>array</code> or <code>sizedarray</code> data types, and described above. For example, if your datatype often contains 32-byte long character strings, you can define an alias as follows:</p>

<pre><code>serial.alias.string32 = {'bytes', 32}
</code></pre>

<p>You can then read such strings with the <code>serial.read.string32</code> function, or even include that new data type in compounds types, for example:</p>

<pre><code>serial.struct.disk = {
    {'artist', 'string32'},
    {'title', 'string32'},
    {'genre', 'string32'},
}
</code></pre>

<h2>4.4 - Data type reference</h2>


	<div class="function">
	<h3><a name="uint8"><code>uint8</code></a></h3>



		</div>
	<div class="function">
	<h3><a name="uint16"><code>uint16 ( endianness )</code></a></h3>



		</div>
	<div class="function">
	<h3><a name="uint32"><code>uint32 ( endianness )</code></a></h3>



		</div>
	<div class="function">
	<h3><a name="uint64"><code>uint64 ( endianness )</code></a></h3>



		</div>
	<div class="function">
	<h3><a name="enum"><code>enum ( dictionary )</code></a></h3>



		</div>
	<div class="function">
	<h3><a name="flags"><code>flags ( dictionary )</code></a></h3>



		</div>
	<div class="function">
	<h3><a name="sizedbuffer"><code>sizedbuffer ( { size_t }, value_t ... )</code></a></h3>



		</div>
	<div class="function">
	<h3><a name="array"><code>array ( size, value_t ... )</code></a></h3>



		</div>
	<div class="function">
	<h3><a name="sizedvalue"><code>sizedvalue ( { size_t }, { value_t } )</code></a></h3>



		</div>
	<div class="function">
	<h3><a name="sizedarray"><code>sizedarray ( { size_t }, { value_t } )</code></a></h3>



		</div>
	<div class="function">
	<h3><a name="cstring"><code>cstring</code></a></h3>



		</div>
	<div class="function">
	<h3><a name="float"><code>float</code></a></h3>



		</div>
	<div class="function">
	<h3><a name="bytes"><code>bytes ( count )</code></a></h3>



		</div>
	<div class="function">
	<h3><a name="bytes2hex"><code>bytes2hex ( count )</code></a></h3>



		</div>
	<div class="function">
	<h3><a name="bytes2base32"><code>bytes2base32 ( count )</code></a></h3>



		</div>
	<div class="function">
	<h3><a name="boolean8"><code>boolean8</code></a></h3>



		</div>
	<div class="function">
	<h3><a name="struct"><code>struct ( fields )</code></a></h3>



		</div>
	<div class="function">
	<h3><a name="fstruct"><code>fstruct ( f, ... )</code></a></h3>



		</div>
</div>

<div class="chapter" id="footer">
<small>Last update: 2009-05-19 02:29:46+0200</small>
</div>

</body>
</html>

